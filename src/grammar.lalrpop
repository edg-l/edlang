use std::str::FromStr;
use crate::{
    ast,
    tokens::Token,
    lexer::LexicalError,
};

grammar;

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token {
      "let" => Token::KeywordLet,
      "print" => Token::KeywordPrint,
      "identifier" => Token::Identifier(<String>),
      "int" => Token::Integer(<String>),
      "return" => Token::KeywordReturn,
      "fn" => Token::KeywordFn,
      "(" => Token::LeftParen,
      ")" => Token::RightParen,
      "{" => Token::LeftBracket,
      "}" => Token::RightBracket,
      "=" => Token::Assign,
      ";" => Token::Semicolon,
      ":" => Token::Colon,
      "->" => Token::Arrow,
      "," => Token::Coma,
      "+" => Token::OperatorAdd,
      "-" => Token::OperatorSub,
      "*" => Token::OperatorMul,
      "/" => Token::OperatorDiv,
      "%" => Token::OperatorRem,
    }
}

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

pub Program: ast::Program = {
    Statements => ast::Program::new(<>)
}

Statements: Vec<ast::Statement> = {
    Statement => vec![<>],
    <mut s:Statements> <n:Statement> => {
        s.push(n);
        s
    },
};

Statement: ast::Statement = {
    BasicStatement,
    <f:Function> => ast::Statement::Function(f),
};

// statements not including function definitions
BasicStatement: ast::Statement = {
    "let" <i:"identifier"> "=" <e:Expr> ";" => ast::Statement::Variable { name: i, value: e},
    <i:"identifier"> "=" <e:Expr> ";" => ast::Statement::Variable { name: i, value: e},
    "return" <e:Expr?> ";" => ast::Statement::Return(e),
};

ExprOp: ast::OpCode = {
    "+" => ast::OpCode::Add,
    "-" => ast::OpCode::Sub,
};

FactorOp: ast::OpCode = {
    "*" => ast::OpCode::Mul,
    "/" => ast::OpCode::Div,
    "%" => ast::OpCode::Rem,
}

Tier<Op,NextTier>: Box<ast::Expression> = {
    <t:Tier<Op,NextTier>> <o:Op> <n:NextTier> => Box::new(ast::Expression::BinaryOp(t, o, n)),
    NextTier
};

Expr = Tier<ExprOp, Factor>;
Factor = Tier<FactorOp, Term>;

// Terms: variables, literals, calls
Term: Box<ast::Expression> = {
    <i:"identifier"> => Box::new(ast::Expression::Variable(i)),
    <n:Num> => Box::new(ast::Expression::Literal(n)),
    <i:"identifier"> "(" <values:Comma<Term>> ")" => Box::new(ast::Expression::Call { function: i, args: values}),
    "(" <Term> ")"
};

Num: ast::LiteralValue = <n:"int"> => ast::LiteralValue::Integer { bits: None, signed: true, value: n.to_string()};

// Function handling
Param: ast::Parameter = {
    <"identifier"> ":" <"identifier"> => ast::Parameter::new(<>)
};

Params = Comma<Param>;

FunctionReturn: String = {
    "->" <i:"identifier"> => i.to_string(),
}

Function: ast::Function = {
    "fn" <i:"identifier"> "(" <a:Params> ")" <r:FunctionReturn?> "{" <s:Statements> "}" => ast::Function::new(i, a, s, r)
}
