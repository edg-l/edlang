use crate::{
    ast::{self, Spanned},
    tokens::Token,
    lexer::LexicalError,
};

grammar;

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token {
      "let" => Token::KeywordLet,
      "print" => Token::KeywordPrint,
      "struct" => Token::KeywordStruct,
      "if" => Token::KeywordIf,
      "else" => Token::KeywordElse,
      "identifier" => Token::Identifier(<String>),
      "int literal" => Token::Integer(<String>),
      "string literal" => Token::String(<String>),
      "bool literal" => Token::Boolean(<bool>),
      "return" => Token::KeywordReturn,
      "fn" => Token::KeywordFn,
      "ptr" => Token::KeywordPtr,
      "_" => Token::KeywordUnderscore,

      "(" => Token::LeftParen,
      ")" => Token::RightParen,
      "{" => Token::LeftBracket,
      "}" => Token::RightBracket,
      "[" => Token::LeftSquareBracket,
      "]" => Token::RightSquareBracket,
      "<" => Token::LessThanSign,
      ">" => Token::MoreThanSign,
      "=" => Token::Assign,
      ";" => Token::Semicolon,
      ":" => Token::Colon,
      "->" => Token::Arrow,
      "," => Token::Coma,
      "+" => Token::OperatorAdd,
      "-" => Token::OperatorSub,
      "*" => Token::OperatorMul,
      "/" => Token::OperatorDiv,
      "%" => Token::OperatorRem,
      "&&" => Token::OperatorAnd,
      "||" => Token::OperatorOr,
      "==" => Token::OperatorEq,
      "!=" => Token::OperatorNe,

      "bool" => Token::KeywordBool,

      "i8" => Token::Inti8,
      "i16" => Token::Inti16,
      "i32" => Token::Inti32,
      "i64" => Token::Inti64,
      "u8" => Token::Intu8,
      "u16" => Token::Intu16,
      "u32" => Token::Intu32,
      "u64" => Token::Intu64,
    }
}

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

pub Program: ast::Program = {
    Statements => ast::Program::new(<>)
}

Statements: Vec<Spanned<ast::Statement>> = {
    <Statement> => vec![<>],
    <mut s:Statements> <n:Statement> => {
        s.push(n);
        s
    },
};

Statement: Spanned<ast::Statement> = {
    BasicStatement,
    <lo:@L> <f:Function> <hi:@R> => Spanned::new(ast::Statement::Function(f), (lo, hi)),
    <lo:@L> <s:Struct> <hi:@R> => Spanned::new(ast::Statement::Struct(s), (lo, hi)),
};

TypeInfo: Spanned<ast::TypeExp> =  {
    ":" <i:LangType> => i
};

Identifier: Spanned<String> = {
    <lo:@L> <i:"identifier"> <hi:@R> => Spanned::new(i, (lo, hi))
}

// statements not including function definitions
BasicStatement: Spanned<ast::Statement> = {
    <lo:@L> "let" <i:Identifier> <t:TypeInfo?> "=" <e:Expr> ";" <hi:@R> =>
            Spanned::new(ast::Statement::Let { name: i, value: e, value_type: t }, (lo, hi)),
    <lo:@L> <i:Identifier> "=" <e:Expr> ";" <hi:@R> =>
            Spanned::new(ast::Statement::Mutate { name: i, value: e }, (lo, hi)),
    <lo:@L> "if" <cond:Expr> "{" <s:Statements> "}" <e:ElseExpr?> <hi:@R> =>
            Spanned::new(ast::Statement::If {
                condition: cond,
                body: s,
                else_body: e,
                scope_type_info: Default::default(),
                else_body_scope_type_info: Default::default(),
            }, (lo, hi)),
    <lo:@L> "return" <e:Expr?> ";" <hi:@R> => Spanned::new(ast::Statement::Return(e), (lo, hi)),
};

ElseExpr: Vec<Spanned<ast::Statement>> = {
    "else" "{" <s:Statements> "}" => s
}

Level0_Op: ast::OpCode = {
    "&&" => ast::OpCode::And,
    "||" => ast::OpCode::Or,
}

Level1_Op: ast::OpCode = {
    "==" => ast::OpCode::Eq,
    "!=" => ast::OpCode::Ne,
}

Level2_Op: ast::OpCode = {
    "+" => ast::OpCode::Add,
    "-" => ast::OpCode::Sub,
};

Level3_Op: ast::OpCode = {
    "*" => ast::OpCode::Mul,
    "/" => ast::OpCode::Div,
    "%" => ast::OpCode::Rem,
}

Tier<Op,NextTier>: Spanned<Box<ast::Expression>> = {
    <lo:@L> <t:Tier<Op,NextTier>> <o:Op> <n:NextTier> <hi:@R> => Spanned::new(Box::new(ast::Expression::BinaryOp(t, o, n)), (lo, hi)),
    NextTier
};

Expr = Tier<Level0_Op, Expr2>;
Expr2 = Tier<Level1_Op, Expr3>;
Expr3 = Tier<Level2_Op, Expr4>;
Expr4 = Tier<Level3_Op, Term>;

// Terms: variables, literals, calls
Term: Spanned<Box<ast::Expression>> = {
    <lo:@L> <i:"identifier"> <hi:@R> => Spanned::new(Box::new(ast::Expression::Variable {
        name: i
    }), (lo, hi)),
    <lo:@L> <n:Number> <hi:@R> => Spanned::new(Box::new(ast::Expression::Literal(n)), (lo, hi)),
    <lo:@L> <n:StringLit> <hi:@R> => Spanned::new(Box::new(ast::Expression::Literal(n)), (lo, hi)),
    <lo:@L> <n:BoolLiteral> <hi:@R> => Spanned::new(Box::new(ast::Expression::Literal(n)), (lo, hi)),
    <lo:@L> <i:Identifier> "(" <values:Comma<Term>> ")" <hi:@R> => Spanned::new(Box::new(ast::Expression::Call { function: i, args: values }), (lo, hi)),
    "(" <Term> ")"
};

Number: ast::LiteralValue = {
    <n:"int literal"> "_"? "i8" => ast::LiteralValue::Integer {
        value: n,
        bits: 8,
        signed: true,
    },
    <n:"int literal"> "_"? "i16" => ast::LiteralValue::Integer {
        value: n,
        bits: 16,
        signed: true,
    },
    <n:"int literal"> "_"? "i32" => ast::LiteralValue::Integer {
        value: n,
        bits: 32,
        signed: true,
    },
    <n:"int literal"> "_"? "i64" => ast::LiteralValue::Integer {
        value: n,
        bits: 64,
        signed: true,
    },
    <n:"int literal"> "_"? "u8" => ast::LiteralValue::Integer {
        value: n,
        bits: 8,
        signed: false,
    },
    <n:"int literal"> "_"? "u16" => ast::LiteralValue::Integer {
        value: n,
        bits: 16,
        signed: false,
    },
    <n:"int literal"> "_"? "u32" => ast::LiteralValue::Integer {
        value: n,
        bits: 32,
        signed: false,
    },
    <n:"int literal"> "_"? "u64" => ast::LiteralValue::Integer {
        value: n,
        bits: 64,
        signed: false,
    },
    <n:"int literal"> => ast::LiteralValue::Integer {
        value: n,
        bits: 32,
        signed: true,
    },
};

StringLit: ast::LiteralValue = <n:"string literal"> => ast::LiteralValue::String(n[1..(n.len()-1)].to_string());

BoolLiteral: ast::LiteralValue = <n:"bool literal"> => ast::LiteralValue::Boolean(n);

ArrayLen: u32 = {
    ";" <i:"int literal"> => i.parse().unwrap(),
}

LangType: Spanned<ast::TypeExp> = {
    <lo:@L> "ptr" "<" <target:LangType> ">" <hi:@R> => Spanned::new(ast::TypeExp::Pointer { target: Spanned::new(Box::new(target.value), target.span) }, (lo, hi)),
    <lo:@L> "[" <of:LangType> <len:ArrayLen?> "]" <hi:@R> => Spanned::new(ast::TypeExp::Array { of: Spanned::new(Box::new(of.value), of.span), len }, (lo, hi)),
    <lo:@L> "i8" <hi:@R> => Spanned::new(ast::TypeExp::Integer { bits: 8, signed: true }, (lo, hi)),
    <lo:@L> "i16" <hi:@R> => Spanned::new(ast::TypeExp::Integer { bits: 16, signed: true }, (lo, hi)),
    <lo:@L> "i32" <hi:@R> => Spanned::new(ast::TypeExp::Integer { bits: 32, signed: true }, (lo, hi)),
    <lo:@L> "i64" <hi:@R> => Spanned::new(ast::TypeExp::Integer { bits: 64, signed: true }, (lo, hi)),
    <lo:@L> "u8" <hi:@R> => Spanned::new(ast::TypeExp::Integer { bits: 8, signed: false }, (lo, hi)),
    <lo:@L> "u16" <hi:@R> => Spanned::new(ast::TypeExp::Integer { bits: 16, signed: false }, (lo, hi)),
    <lo:@L> "u32" <hi:@R> => Spanned::new(ast::TypeExp::Integer { bits: 32, signed: false }, (lo, hi)),
    <lo:@L> "u64" <hi:@R> => Spanned::new(ast::TypeExp::Integer { bits: 64, signed: false }, (lo, hi)),
    <lo:@L> "bool" <hi:@R> => Spanned::new(ast::TypeExp::Boolean, (lo, hi)),
    <lo:@L> <id:"identifier"> <hi:@R> => Spanned::new(ast::TypeExp::Other { id }, (lo, hi)),
};

// Function handling
Param: ast::Parameter = {
    <Identifier> ":" <LangType> => ast::Parameter::new(<>)
};

Params = Comma<Param>;

FunctionReturn: Spanned<ast::TypeExp> = {
    "->" <i:LangType> => i,
}

Function: ast::Function = {
    "fn" <i:Identifier> "(" <a:Params> ")" <r:FunctionReturn?> "{" <s:Statements> "}" => ast::Function::new(i, a, s, r)
}

// Structures

StructField: ast::StructField = {
    <Identifier> ":" <LangType> => ast::StructField::new(<>)
};

StructFields = Comma<StructField>;

Struct: ast::Struct = {
    "struct" <i:Identifier> "{" <fields:StructFields> "}" => {
        ast::Struct {
            name: i,
            fields
        }
    }
}
