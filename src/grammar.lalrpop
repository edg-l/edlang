use std::str::FromStr;
use crate::{
    ast,
    tokens::Token,
    lexer::LexicalError,
};

grammar;

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token {
      "let" => Token::KeywordLet,
      "print" => Token::KeywordPrint,
      "struct" => Token::KeywordStruct,
      "if" => Token::KeywordIf,
      "else" => Token::KeywordElse,
      "identifier" => Token::Identifier(<String>),
      "int" => Token::Integer(<String>),
      "return" => Token::KeywordReturn,
      "fn" => Token::KeywordFn,
      "(" => Token::LeftParen,
      ")" => Token::RightParen,
      "{" => Token::LeftBracket,
      "}" => Token::RightBracket,
      "=" => Token::Assign,
      ";" => Token::Semicolon,
      ":" => Token::Colon,
      "->" => Token::Arrow,
      "," => Token::Coma,
      "+" => Token::OperatorAdd,
      "-" => Token::OperatorSub,
      "*" => Token::OperatorMul,
      "/" => Token::OperatorDiv,
      "%" => Token::OperatorRem,
      "&&" => Token::OperatorAnd,
      "||" => Token::OperatorOr,
      "==" => Token::OperatorEq,
      "!=" => Token::OperatorNe,
    }
}

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

pub Program: ast::Program = {
    Statements => ast::Program::new(<>)
}

Statements: Vec<ast::Statement> = {
    Statement => vec![<>],
    <mut s:Statements> <n:Statement> => {
        s.push(n);
        s
    },
};

Statement: ast::Statement = {
    BasicStatement,
    <f:Function> => ast::Statement::Function(f),
};

TypeInfo: String =  {
    ":" <i:"identifier"> => i
};

// statements not including function definitions
BasicStatement: ast::Statement = {
    "let" <i:"identifier"> <t:TypeInfo?> "=" <e:Expr> ";" => ast::Statement::Let { name: i, value: e, type_name: t},
    <i:"identifier"> "=" <e:Expr> ";" => ast::Statement::Mutate { name: i, value: e},
    "if" <cond:Expr> "{" <s:Statements> "}" <e:ElseExpr?> => ast::Statement::If { condition: cond, body: s, else_body: e},
    "return" <e:Expr?> ";" => ast::Statement::Return(e),
};

ElseExpr: Vec<ast::Statement> = {
    "else" "{" <s:Statements> "}" => s
}

Level0_Op: ast::OpCode = {
    "&&" => ast::OpCode::And,
    "||" => ast::OpCode::Or,
}

Level1_Op: ast::OpCode = {
    "==" => ast::OpCode::Eq,
    "!=" => ast::OpCode::Ne,
}

Level2_Op: ast::OpCode = {
    "+" => ast::OpCode::Add,
    "-" => ast::OpCode::Sub,
};

Level3_Op: ast::OpCode = {
    "*" => ast::OpCode::Mul,
    "/" => ast::OpCode::Div,
    "%" => ast::OpCode::Rem,
}

Tier<Op,NextTier>: Box<ast::Expression> = {
    <t:Tier<Op,NextTier>> <o:Op> <n:NextTier> => Box::new(ast::Expression::BinaryOp(t, o, n)),
    NextTier
};

Expr = Tier<Level0_Op, Expr2>;
Expr2 = Tier<Level1_Op, Expr3>;
Expr3 = Tier<Level2_Op, Expr4>;
Expr4 = Tier<Level3_Op, Term>;

// Terms: variables, literals, calls
Term: Box<ast::Expression> = {
    <i:"identifier"> => Box::new(ast::Expression::Variable(i)),
    <n:Number> => Box::new(ast::Expression::Literal(n)),
    <i:"identifier"> "(" <values:Comma<Term>> ")" => Box::new(ast::Expression::Call { function: i, args: values}),
    "(" <Term> ")"
};

Number: ast::LiteralValue = <n:"int"> => ast::LiteralValue::Integer { bits: None, signed: true, value: n.to_string()};

// Function handling
Param: ast::Parameter = {
    <"identifier"> ":" <"identifier"> => ast::Parameter::new(<>)
};

Params = Comma<Param>;

FunctionReturn: String = {
    "->" <i:"identifier"> => i.to_string(),
}

Function: ast::Function = {
    "fn" <i:"identifier"> "(" <a:Params> ")" <r:FunctionReturn?> "{" <s:Statements> "}" => ast::Function::new(i, a, s, r)
}
