use std::str::FromStr;
use crate::ast::*;

grammar;

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

ExprOp: OpCode = {
    "+" => OpCode::Add,
    "-" => OpCode::Sub,
};

FactorOp: OpCode = {
    "*" => OpCode::Mul,
    "/" => OpCode::Div,
    "%" => OpCode::Rem,
}

Tier<Op,NextTier>: Box<Expression> = {
    <t:Tier<Op,NextTier>> <o:Op> <n:NextTier> => Box::new(Expression::BinaryOp(t, o, n)),
    NextTier
};

Expr = Tier<ExprOp, Factor>;
Factor = Tier<FactorOp, Term>;

// Terms: variables, literals, calls
Term: Box<Expression> = {
    <i:Identifier> => Box::new(Expression::Variable(i)),
    <n:Num> => Box::new(Expression::Literal(n)),
    <i:Identifier> "(" <values:Comma<Term>> ")" => Box::new(Expression::Call { function: i, args: values}),
    "(" <Term> ")"
};

Identifier: String = {
    <i:r"[a-zA-Z][\w]*"> => i.to_string(),
};

Num: LiteralValue = <n:r"[0-9]+"> => LiteralValue::Integer { bits: 32, signed: true, value: n.to_string()};

// Function handling
Param: Parameter = {
    <Identifier> ":" <Identifier> => Parameter::new(<>)
};

Params = Comma<Param>;

FunctionReturn: String = {
    "->" <i:Identifier> => i.to_string(),
}

Function: Function = {
    "fn" <i:Identifier> "(" <a:Params> ")" <r:FunctionReturn?> "{" <s:Statements> "}" => Function::new(i, a, s, r)
}

// statements not including function definitions
BasicStatement: Statement = {
    "let" <i:Identifier> "=" <e:Expr> ";" => Statement::Variable { name: i, value: e},
    <i:Identifier> "=" <e:Expr> ";" => Statement::Variable { name: i, value: e},
    "return" <e:Expr?> ";" => Statement::Return(e),
};

Statement: Statement = {
    BasicStatement,
    <f:Function> => Statement::Function(f),
};

Statements: Vec<Statement> = {
    Statement => vec![<>],
    <mut s:Statements> <n:Statement> => {
        s.push(n);
        s
    },
};

pub Program: Program = {
    Statements => Program::new(<>)
}
